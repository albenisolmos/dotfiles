#include "ol_box_expander.h"


static void on_drag_begin(GtkWidget *widget, GdkDragContext *context,
		gpointer data);

static gboolean on_drag_motion(
		GtkWidget *widget,
		GdkDragContext *context,
		gint x,
		gint y,
		guint t,
		gpointer data 
);
/*
static void on_drag_data_get(
		GtkWidget *widget,
		GdkDragContext *context,
		GtkSelectionData *selection_data,
		guint info,
		guint32 time,
		gpointer data
);
*/
static void on_drag_data_received(
		GtkWidget *widget,
		GdkDragContext *context,
		gint x,
		gint y,
		GtkSelectionData *selection_data,
		guint info,
		guint32 time,
		gpointer data
);

void ol_dnd_expander_setup_dest(GtkWidget *box, GtkTargetEntry *entries)
{
	gtk_drag_dest_set(box, GTK_DEST_DEFAULT_ALL, entries, 1, GDK_ACTION_MOVE);

	g_signal_connect(G_OBJECT(box), "drag-data-received",
		  G_CALLBACK(on_drag_data_received), NULL);
//	g_signal_connect (G_OBJECT(box), "drag-motion",
//			G_CALLBACK (on_drag_motion), NULL);
}

GtkWidget *ol_dnd_expander_setup_child(GtkWidget *child, GtkTargetEntry *entries)
{
	g_return_val_if_fail(child != NULL, NULL);
	GtkWidget *box, *handle;

	box = gtk_box_new (GTK_ORIENTATION_HORIZONTAL, 10);
	g_object_set (box, "margin-start", 10, "margin-end", 10, NULL);
	gtk_container_add(GTK_CONTAINER(child), box);

	handle = gtk_event_box_new ();
	gtk_container_add(GTK_CONTAINER (handle), child);
	gtk_container_add (GTK_CONTAINER (box), handle);

	gtk_drag_source_set(handle, GDK_BUTTON1_MASK, entries, 1, GDK_ACTION_MOVE);
	g_signal_connect(child, "drag-begin", G_CALLBACK( on_drag_begin ), NULL);
	//g_signal_connect(child,"drag-data-get", G_CALLBACK(on_drag_data_get) NULL);

	gtk_drag_dest_set(handle, GTK_DEST_DEFAULT_ALL, entries, 1, GDK_ACTION_MOVE);
	g_signal_connect(G_OBJECT(handle), "drag-data-received",
		  G_CALLBACK(on_drag_data_received), NULL);
	g_signal_connect(G_OBJECT(handle), "drag-motion", G_CALLBACK(on_drag_motion),
			child);

	return box;
}

static void on_drag_data_received(
		GtkWidget *widget,
		GdkDragContext *context,
		gint x,
		gint y,
		GtkSelectionData *selection_data,
		guint target_type,
		guint32 time,
		gpointer data
) {
	g_message("on_drag_data_received %d", target_type);
	g_message("%s", (char*) gtk_selection_data_get_data(selection_data));
}

static void on_drag_begin(GtkWidget *widget, GdkDragContext *context, gpointer data)
{
	GtkWidget *row;
	GtkAllocation alloc;
	cairo_surface_t *surface;
	cairo_t *cr;
	int x, y;
	double sx, sy;

	row = gtk_widget_get_ancestor (widget, GTK_TYPE_LIST_BOX_ROW);
	gtk_widget_get_allocation (row, &alloc);
	surface = cairo_image_surface_create (CAIRO_FORMAT_ARGB32, alloc.width, alloc.height);
	cr = cairo_create (surface);

	gtk_style_context_add_class (gtk_widget_get_style_context (row), "drag-icon");
	gtk_widget_draw (row, cr);
	gtk_style_context_remove_class (gtk_widget_get_style_context (row), "drag-icon");

	gtk_widget_translate_coordinates (widget, row, 0, 0, &x, &y);
	cairo_surface_get_device_scale (surface, &sx, &sy);
	cairo_surface_set_device_offset (surface, -x * sx, -y * sy);
	gtk_drag_set_icon_surface (context, surface);

	cairo_destroy (cr);
	cairo_surface_destroy (surface);
}

/*
static void ol_dnd_expander_on_drag_data_get(
		GtkWidget *widget,
		GdkDragContext *context,
		GtkSelectionData *selection_data,
		guint info,
		guint32 time,
		gpointer data
) {
	gtk_selection_data_set(
			selection_data,
			gdk_atom_intern_static_string("GTK_LIST_BOX_ROW"),
			32,
			(const guchar *) &widget,
			sizeof (gpointer)
	);
}
*/

static gboolean on_drag_motion(
		GtkWidget *widget,
		GdkDragContext *context,
		gint x, gint y, guint t,
		gpointer user_data
) {
	GtkAllocation alloc;
	if (widget == NULL)
		g_message("NULL");
	gtk_widget_get_allocation(GTK_WIDGET((GtkWidget*)user_data), &alloc);
	g_message("y: %d, x: %d, h: %d, w: %d", alloc.y, alloc.x, alloc.height, alloc.width);
	// Fancy stuff here. This signal spams the console something horrible.
	//const gchar *name = gtk_widget_get_name (widget);
	//g_print ("%s: drag_motion_handl\n", name);
	return  FALSE;
}
