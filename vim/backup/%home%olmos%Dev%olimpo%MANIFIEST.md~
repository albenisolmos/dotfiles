# Items
## {Block}
{ ... }

## {ID}
A unique identifier

## {IDType}
id of all buidt-in type class and user defined

## {IDTyped}
A unique identifier with a type specified
* Format: {ID}:{IDType}

## {IDTypedExpr}
A unique identifier with a type expresion specified
* Format: {ID}:{TypeExpr}
* Example: `length: int||none`, `iterable: T && std::Iterable`

## {StorageClass}
* let: 
* const:
* mut: 
* dyn:

## {BlockList}
{item, ...}

## {ArgsList}
()

# STDLibs

## Array Lib
range(from: int)
range(from: int, to: int)
concat(a, b, array): array
insert(a: array, value: any)
insert(a: array, pos: int, value: any)
remove(a: array, idx: int)
remove(a: array, el: &any)
filter(a: array, filter: fn): array
from()

##Assert Lib
assert(expr: bool)
assert(expr: bool, strerror: str)
assert(expr: bool, error: Error, strerror: str)
pcall(call: fn, ...)

##Math Lib
sqrt(x: int)
pow(x, y, int)
max(x: int)
min(x: int)
abs(x: int): uint
floor(x: int)

##fs (filesystem)
* open
* goto
* delete
* move

class Persona {
	new() {}

	new(name: str, age: int) {
		self.new(name);
		self.age = age
	}

	new(name: str) {
		self.name = name
	}

	name(self) {
		return self.name
	}

	name(self, name) {
		self.name = name
	}

	age(self, value: int) {
		self.age = value
	}

	age(self) {
		return self.age
	}

	private:
		age: int
		name: str 
}

class Hero(Persona) {
	new(name: str) {
		super(name)
	}

	new(name: str, age: int) {
		super(name, age)
	}

	add_ability(ability_name: str, ability: fn) {
		self.abilities[ability_name] = fn 
	}

	private abilities: array
	private strength: int = 10
}

// implementation of a hero who can increase his own strength
{
	const hero = Hero::new('un_loco')
	hero.add_ability('increase-strength', fn(self) {
		self.strength += 10
	})
}
// comment inline
/* comment multiline */

# Intruction for the interpreter
* **ignore**: ignore the next block

## Conditionals

if {expr} {Block}
else {block}
match {val} {block}

// Examples
fn get_biggest(a: int, b: int, c: int = 0) {
	return if a > b && a > c -> a
		elseif b > a && b > c  -> b
		elseif c > b && c > a -> c
}

fn is_good_resolution(resolution: int) {
	return match resolution {
		1080 -> 'it\'s full hd'
		720 -> 'it\'s hd'
		420 -> 'it\'s aceptable'
		(* < 420) -> 'looks ugly'
		* -> Error('Invalid resolution')
	}
}

fn color_for_mood(mood: str)
	match mood {
		'angry': set_color('red')
		'sick': set_color('green')
		* -> Error('Unknow Mood')
	}
}
// Scope design
import io
import Array

// (.) access to member of namespace io
io.println('test of scope')
// (:) set context (self) to a object
('abcdefg'):Array::
// (::) acces to a member of namespace io  
io::println('test of scope')

# Function
* **Format**: `fn {id} ({list{_}}): {IDType} {Block}`

## Example
fn add(a, b) { return a + b }
fn sustract(a: int, b: int) { return a - b }
fn foo(): void {}
fn foo() {}

## Lambda function
const pair = (a,b) => { a % 2 == 0 }
const show_if_pair = fn(a,b) {
	print(if a % 2 == 0 'It is pair'
		else 'It is not pair')
}

// Multiple version
fn add(a: int, b: int): int {
	return a + b
}
fn add(a: array, b: array): array {
	return a.concat(b)
}

// Calling functions

// functions can be called naming his his paramenters
fn create_quad(color: str, height: int, width: int) {...}
create_quad(color = '#228ae7')
create_quad(height = 500, width = 200)
create_quad(
	color = '#228ae7',
	height = 500,
	width = 200
)

// Functions can had a specify class type to return
fn filter(arr: array, func: fn): array
	let result
	for const i in arr {
		len_result = result.length()
		if func(i, len_result)
			result[len_result + 1] = i
	}
	return result
}

// Functions can return a set of values with "()"
fn get_geometry() {
	...
	return (w, h)
}
const (width, height) = get_geometry()

 fn ensure!(afunc?: Function)	
	if (typeof(afunc) == 'Function')
		return afunc
end
ensure(null)
ensure(exist_function)

OPP will work of this way

class Person {
	new()
	eat()
	grow_up()
}

let person1 = Person::new()
person1.eat()
person1.grow_up()

// This gonna be translate

Person *person1 = new class_Person_new()
class_Person_eat(person1)
class_Person_grow_up(person1)
import io 
import io as IO
import print from io
import {
	aTool,
	otherTool
} from Utils 

export [namespace,functions,...] 
export * from io 

import math
import {
	Button,
	Image,
	Box,
	Window
} from gtk 

import fs as filesystem
filesystem.open as fopen

# Loops
* **Format**: while {Expr} {Block}
* for <initial variable>; <condition>; <operation> {}
* for <initial variable> in <Iterable> {}

// Notes
// if you <initial variable> is declare with "let"
// the loop will recycle tha variable
 
// Examples
while true {}
while i < 10 {}
for const item in list {}
for let item in list {}
for let i, i < 10, i++ {}
free()
alloc(obj, size)
realloc(obj, size)
delete {obj}

# Metamethods
* **\_asign_**: =
* **\_add_**: z + x
* **\_del_**: delete x
* **\_substract_**: z - x
* **\_equal_**: z == x
* **\_noequal_**: z != x
* **\_lessthan_**: z < x
* **\_lessequal_**: z <= x
* **\_majorthan_**: z > x
* **\_majorequal_**:z >= x
* **\_init_**: () {}

* **Example**:\
`class Group {
	Group(name: str) {
		self.name = name
	}

	Group() { }

	add_member(member: str) {
		self.members.push(member) {
	}

	add_member(members: str[]) {
		for let member in members {
			self.members.push(member) {
		}
	}

	delete_member(member: str) {
		self.members = self.members.splice(self.members.find_index(member))
	}

	_add_(a, b) {
		let group = Group()
		group << a.members()
		group << b.members()
		return group
	}

	_inflow_(a,b: str||str[]) {
		a.add_member(b) {
	}

	_outflow_(a , b: str||str[]) {
		self.members();
	}

	priv members: Array 
}`

// Use
fn using_methatmethods() {
	const group1 = Group() 
	const group2 = Group()
	return group1 + group2
}
class Person
	name(str)
	age(int)
	gender('female' | 'male')
end

let a_person = Person()
		| name('albenis')
		| age(17)
		| gender('male')

let other_person = Person(), name('krueger'), gender('male')

DESIGN ISSUES
const test = 1000,
	another_person = Person()
		|> name('krueger')
		|> gender('male'),
	test2 = 2000

# Operators
* !, negation
* ||,  or
* &&       | and
* << >>    | flow
* => <=    | major/minor equal
* ==       | equal
* !=       | not equal 
* &        | reference
* ?=       | asig if not false
* instaceof
* in
* #        | length
* <        | minor
* >        | major
n..n     | iterator
const fn a_purre_function() {
	/* the (const) statement make the function
		pure and it make it 
	*/
}

# Structs

## Struct
* **Format**: `struct {id} {list_block}`
{type}[]

## Array
**Format**: `struct {id} {list_block}`\
### Example
	let my_array: int[] = [1,2,3,4]
	let my_array: str[] = ['a', 'b', 'c']
	let my_array: array = ['a', 2, 'c']
	let my_array: array[]
	let my_array = ['a', 2, 'c']

##Index Operator
	let num_array = [1,2,3,4,5,6]
	num_array[0] // 1
	num_array[5] // 6
	num_array[:4] // 1 2 3 4 5
	num_array[4:] // 6
	num_array[1:2] // 2 3

## Dictionaries
### Example
	let dic = {
		loco = 666,
		age = 17,
		code = true
	}

print(my_dic['loco'])
print(my_dic.loco)

import Gtk

fn main() {
	let button1 = Gtk.ToggleButton('the button 1')
		| onclick = fn() print('button1 clicked')
	let button2 = Gtk.ToggleButton('the button 2')
		| onclick = fn() print('button2 clicked') 

	Gtk::BuilderUI({
		Gtk::Box {
			Gtk::ButtonBox {
				button1,
				button2
			},
			Gtk::Notebook,
			orientation = 'vetical'
			spacing = 10
		}
	})
}

# Types

int // integer (i64 by default)
int{bits} // integer of {8, 16, 32, 64, 128} bits
uint // unsigned integer (i64 by default)
uint{bits} // unsigned integer of 16,21,64,128
str // string
[] // array
array
{type}[] // an array of {type}
// Declaring
<storage class> <variable name> : <class type> 
// Declaring a set
<storage class> (<variables name>) : <class type>
// Asinging
<declared variable name> = <value acording to his <class type>>

// Storage Class
let // Default storage class (mut)
const // Constant storage class
mut // Mutable storage class

// Examples

let mut_var = 10
mut_var = 20
mut_var = 'loco'

const const_var = 10

let str_var: str = 'loco'

const (var1, var2, var3): int = 1, 2, 3
let (var1, var2, var3): str

mut str_var: str = 'loco'
mut (var1, var2, var3): str
mut (var1, var2, var3): str = 'a', 'b', 'c'
// asign by sets
let (width, height) = get_geometry()
let (intvar, intvar2): int

// Operator of return to context (->)
let ispair = if (10 % 2 == 0) -> 'is pair' else -> 'isnt pair'

// Operator of asignment conditional (?=)
// Only asign if the value is diferent to null false or none
fn set_value(self, value_name, value) {
	self[value_name] ?= value
}

// Finish a block of code on runtime and never execute anymore (done)
for let i; i < 1000; i++ {
	if i == 1 {
		...
		done
	}
	...
}
